Fixing and Completing the Stripe Subscription Flow
1. Revised Flow Structure (Onboarding to Payment)
Ensure the user signup flow follows the sequence: Splash Screen → Login/Register → Onboarding → Plan Selection → Payment → Homepage. New users should not gain access to the app or be persisted in the database until the onboarding and plan selection are completed:
Delayed User Creation: Do not create the user in the database immediately upon registration. Instead, after a new user signs up (provides email/password), direct them into the onboarding slides without saving the account yet. This prevents half-created accounts if the user abandons the flow during onboarding.
Onboarding Slides: Present the introductory/tutorial screens. These should always appear for new signups before plan choice. (Ensure returning users or logged-in users skip this.)
Plan Selection (Free vs Premium): On the final onboarding screen, prompt the user to choose a plan: either Free or Premium (with Monthly/Yearly options).
Free Plan: If the user selects the free tier, immediately create the user account in the database at this point. Mark their status/plan as “free” (e.g. a plan field or isPremium=false). Then log them in and redirect to the app’s homepage with free-tier access.
Premium Plan: If the user opts for a premium subscription (monthly or yearly), initiate the payment flow before creating the user account. This means launching the Stripe Checkout process for the selected plan. Only create the user in the database after a successful payment confirmation. This ensures you only create paying user accounts for those who actually complete the purchase.
Post-Payment Account Creation: After a successful Stripe Checkout (detailed below), create the user in the database and set their status as “premium”. Also record relevant subscription info (e.g. Stripe customer ID, subscription ID, plan type, and the current period end date). Finally, redirect the now-paying user to the homepage and log them in.
By following this order, free users get instant access after onboarding, while premium users go through the payment step. No user record is saved until the last step, preventing “free riders” who close the payment page from getting an account. Also ensure your routing logic forces new users through onboarding first: e.g. if a new user somehow tries to skip directly to the app without completing onboarding/plan, redirect them back into the onboarding flow. This will fix any routing issues where users were accessing the app without choosing a plan.
2. Stripe Integration (Checkout Session for Subscriptions)
Use Stripe Checkout in test mode to handle subscription payments for premium plans. In test mode, use your Stripe test publishable/secret keys (pk_test_xxx / sk_test_xxx) and test price IDs. Key implementation points:
Checkout Session Setup: When a user chooses a premium plan, create a Checkout Session via Stripe’s API instead of manually creating a subscription. The Checkout Session will handle collecting payment details securely and creating the subscription. Include the appropriate Price ID based on the user’s selection (monthly or yearly plan). For example, using Stripe’s Node library:
js
Copy
const session = await stripe.checkout.sessions.create({
  mode: 'subscription',
  line_items: [
    { price: monthlyPriceId, quantity: 1 }
  ],
  success_url: 'https://your-app.com/checkout-success?session_id={CHECKOUT_SESSION_ID}',
  cancel_url: 'https://your-app.com/plan-selection?canceled=true',
  // ... (optionally customer_email or client_reference_id)
});
Here, line_items must include the exact Stripe Price ID for the chosen plan (e.g. price_12345 for monthly or price_67890 for yearly)​
REDDIT.COM
. If the user selected an annual plan, pass that price ID instead. (Alternatively, you can include both monthly and yearly price objects in line_items to let Stripe display both options on the checkout page​
REDDIT.COM
, but since the user already chose on your UI, just pass the one they picked.) Using the Stripe Checkout session ensures required parameters (like line_items) are provided, avoiding API errors. For instance, an earlier implementation that attempted to create subscriptions directly may have failed with errors like “Missing required param: items”​

, which using Checkout correctly will solve.
Collecting Customer Info: Provide customer_email in the session creation if you have the user’s email from registration. This pre-fills the email on Stripe Checkout and ensures the Stripe Customer is created with that email​
DEV.TO
. You can also use client_reference_id to pass a reference (like a temp user ID or signup token) to identify the session in your system​
DEV.TO
. This will help link the Stripe session back to the user if needed (e.g. in webhook processing). Since we deliberately haven’t created a user yet for new premium signups, you might use a temporary identifier or simply rely on the email for linkage.
Redirect to Stripe: Once the Checkout Session is created (via a backend API call), use the session’s URL to redirect the user to Stripe’s hosted payment page. In a web app, this can be done by setting window.location = session.url after receiving the session ID/url from your backend. The user will see Stripe’s checkout form to enter payment details.
Success and Cancel URLs: Define a success_url and cancel_url in the session. The success_url should point to a route in your app that handles post-payment success (e.g. a page that finalizes account creation). Include the placeholder {CHECKOUT_SESSION_ID} in the success URL so Stripe will replace it with the actual session ID – you can use this to verify payment on return. The cancel_url should bring the user back to your app (e.g. the plan selection page) if they abandon or the payment fails. In our example above, cancel_url is set with a query param canceled=true so the app knows to show a failure message.
Test Mode: Use Stripe’s test mode for development. That means using test API keys and sample cards (like 4242 4242 4242 4242) to simulate payments. Verify that the Checkout is indeed creating a subscription (mode=subscription) with the correct price. In test mode, you can see the Checkout Session and Subscription objects in your Stripe Dashboard (developers section) to confirm the flow.
Implementing the payment step with Stripe Checkout in this way addresses previous payment issues. It ensures the price ID is always sent (preventing “required param: items” errors) and delegates secure payment collection to Stripe. It also means you don’t manually call stripe.subscriptions.create or other complex APIs – Checkout does it for you, simplifying the flow​
DEV.TO
​
DEV.TO
.
3. Webhook Integration for Subscription Events
After integrating Checkout, set up Stripe webhooks to keep your system in sync with Stripe events. Webhooks will notify your backend of important events in case the user does not return to the site or for ongoing subscription changes. Specifically handle:
checkout.session.completed: Triggered when a Checkout Session is successfully completed (payment succeeded)​
PEDROALONSO.NET
. In this handler, you can finalize the account provisioning for premium users. For a new user signup, upon receiving this event, verify the session and then create the user account if not already created (using the email or client_reference_id from the session to identify them). Mark the user as premium and store their Stripe Customer ID (session.customer) and Subscription ID (session.subscription) in your database​
DEV.TO
. (If your flow already created the user right after the Stripe redirect success, then the webhook can be a backup check – but generally it’s good to idempotently ensure the user is created/updated here.) For existing users upgrading to premium, this event simply confirms the subscription creation – update their status to premium. In all cases, you might record the subscription’s current_period_end date (via the Subscription API) at this point.
invoice.payment_succeeded (aka invoice.paid): Fires whenever an invoice is paid​
PEDROALONSO.NET
 – i.e. on recurring subscription renewals (and also the initial charge if no trial). Use this to update the user’s subscription status and period. For example, when a renewal payment succeeds, you can extend the user’s access: update the subscription_end or premium_until date in your database to the new period end. This event tells you the payment for the current period is confirmed, so the subscription remains active. (If you stored current_period_end from the subscription, you may update it here by fetching the subscription or reading the invoice’s period end.) This ensures that even if the user’s app is open, your backend knows their premium access is paid for the next cycle.
customer.subscription.updated: Handle updates to the subscription​
DOCS.STRIPE.COM
. This event is sent when a subscription’s properties change – notably when a user cancels their subscription (sets it to cancel at period end) or resumes it. According to Stripe, “customer.subscription.updated” is sent when you cancel a subscription at period end (it reflects the cancel_at_period_end field change)​
DOCS.STRIPE.COM
. In the webhook handler, check the payload for cancel_at_period_end or status changes. For example, if cancel_at_period_end just became true, it means the user has scheduled a cancellation. You should update your database to mark that the user’s subscription will end at the period end date. You might set a flag like subscriptionCancelling=true or simply note the premium_until date and know not to renew beyond it. If the event also provides a current_period_end, update that in the user record – the user should retain premium status until that date. Similarly, if cancel_at_period_end is false (perhaps the user renewed or you uncancelled), ensure your records reflect that. This event can also cover plan upgrades/downgrades if you allow switching plans mid-cycle – in such cases update the stored plan info.
customer.subscription.deleted: Emitted when a subscription is fully canceled or ends​
PEDROALONSO.NET
. If a user’s subscription lapses (either an immediate cancellation or it reached end of period), this webhook tells you the subscription object is now canceled. In this handler, find the corresponding user in your database (e.g. by Stripe customer or subscription ID) and revoke their premium access. Set their plan/status back to “free” (or however you denote a non-subscriber)​
PEDROALONSO.NET
. You might also clear any stored subscription IDs or set a field like premium_until to the cancellation date. Essentially, this is the point to downgrade the user in your system, since their paid time is over. Be sure to only do this when you receive the actual deletion (or after the end date), not at the moment they press “cancel” (that’s handled by the updated event above).
Webhook Security: Remember to secure your webhook endpoint by verifying Stripe’s signature (using the signing secret). Also, handle idempotency – Stripe may resend events – so your handlers should safely handle duplicate notifications (e.g. by checking if you already processed a given subscription ID update). By implementing these webhooks, your app’s user records will stay in sync with Stripe. For example, when a user cancels, Stripe will send customer.subscription.updated and you mark the user as pending cancellation until current_period_end. When the date passes and Stripe sends customer.subscription.deleted, you downgrade the account. Likewise, on successful renewal payments (invoice.paid), you extend their access and could send a “Thank you for your payment” email, etc. This covers cases where a user might cancel or payment fails outside of an active app session. (Note: if using Stripe test mode, be sure to test these events using the Stripe CLI or Dashboard by triggering test webhooks, to ensure your logic works.)​
PEDROALONSO.NET
4. Settings Page – Upgrade & Cancel Functionality
The Settings page must allow a logged-in user to upgrade to premium or cancel their subscription, fully integrated with Stripe:
Upgrade Button: Replace the current dummy upgrade button with a real flow. If a free user clicks “Upgrade to Premium” in settings, you can reuse the Stripe Checkout flow described earlier. For example, call your backend to create a Checkout Session for the premium plan (likely default to monthly, or allow them to pick plan in the UI before clicking). Because this is an existing user, you should supply Stripe with this user’s Stripe Customer ID if they have one. If the user never had a Stripe customer (i.e. they’ve been free so far), you can create one on the fly or let Checkout create it. Ideally, retrieve the user’s email from your DB and use customer_email or customer in the session creation. This avoids creating duplicate customers on Stripe​
GITHUB.COM
 (in case the user had a previous Stripe record). After the user completes Checkout successfully, the checkout.session.completed webhook (and redirect) will mark them as premium in your DB. Make sure to update the UI state (e.g. their account status) after upgrading. Essentially, this upgrade flow in settings is the same as the signup premium flow, except the account exists, so just create a Checkout session and redirect.
Cancel Subscription: If a premium user clicks “Cancel subscription” in settings, implement a confirmation prompt. When the user confirms, you should call Stripe’s API to cancel the subscription at period end. Use the Stripe Subscription ID stored for that user to do this. In Stripe’s API, this is achieved by updating the subscription with cancel_at_period_end: true​
DOCS.STRIPE.COM
. For example, using Node: await stripe.subscriptions.update(subscriptionId, { cancel_at_period_end: true });. This flags the subscription to not renew. According to Stripe’s docs, setting this allows the subscription to continue until the current billing period is over​
DOCS.STRIPE.COM
. The user will not be charged further, but still has access for the remaining time. After calling the API, update your backend to reflect the pending cancellation: e.g. store that cancel_at_period_end is true and record the current_period_end date from the response. You might present this in the UI (e.g. “Your subscription will end on 2025-12-31”). The Stripe webhook for customer.subscription.updated (as noted) will also arrive with this info​
DOCS.STRIPE.COM
, so ensure your webhook handling aligns (it can double-check or update the same info in case the cancel was initiated from Stripe’s side or the portal).
Immediate Cancel vs End-of-Period: The requirement is to keep access until end of billing cycle upon cancellation. So you should not cancel immediately. By using cancel_at_period_end: true, Stripe will not send a customer.subscription.deleted until the period actually ends. The user remains premium in the interim. (If you mistakenly used immediate cancellation, Stripe would end the sub right away and you’d get subscription.deleted immediately, cutting off access. We avoid that.) If needed, you can also provide an option to undo cancellation in that period (Stripe allows reactivating by setting cancel_at_period_end:false before the period ends​
DOCS.STRIPE.COM
, but that could be an advanced feature).
Confirmation UI: The cancel confirmation should be a modal dialog or popup that asks “Are you sure you want to cancel? You will retain premium access until [end date].” Provide two options: Confirm (to proceed with cancellation) or Keep Subscription (to dismiss). This extra step prevents accidental cancels. When confirmed, perform the Stripe API call as above, and then show a feedback message like “Your subscription has been canceled and will end on [date].”. You might change the wording of the button/state to indicate pending cancellation.
Implementing the Upgrade & Cancel in settings in this manner resolves the prior placeholder behavior. Upgrading now truly initiates payment, and canceling cleanly schedules the end of the sub. The UI/UX should reflect the current state: if a user is free, show the upgrade option; if premium, show their plan and the cancel option (and possibly next billing date or cancel status if already set to end).
5. Error Handling and UX Improvements
Improve error handling and page transitions for a smooth user experience:
Payment Failure Feedback: If the Stripe payment fails or is canceled, make sure the user is informed clearly on the page, not just via a fleeting toast. For example, if Stripe Checkout redirects back to your cancel_url (e.g. /plan-selection?canceled=true), detect that and show an error message in the plan selection screen like “Payment was not completed. No charge was made. Please try again or select a different plan.” This message should be prominent (e.g. a red alert box) and remain until the user dismisses it or retries. This way the user understands the outcome. In contrast, a toast might disappear or be missed. Ensure this error state is part of the component state so it survives any re-renders. Also handle any Stripe API errors on your backend (e.g. session creation failures) by propagating a user-friendly message to the frontend.
Prevent Duplicate Submissions: During the payment process, ensure the user cannot accidentally trigger things multiple times. For instance, once the user clicks “Upgrade” and you initiate the Stripe checkout, disable the upgrade button and perhaps show a loading spinner until they are redirected. This prevents double-clicks from creating multiple checkout sessions. Similarly, on the onboarding last step, if they choose premium and you redirect them to Stripe, don’t also create a local account — that should be on hold until payment success.
Smooth Redirects & Transitions: Clean up the navigation flow between screens. After login/registration, automatically route new users into onboarding. Use gentle animations between onboarding slides (if you have multiple slides, implement a swipe or fade transition to make it feel cohesive). When the user finishes onboarding and selects a plan, handle the transition to the next step (Stripe or homepage) smoothly: perhaps show a loading indicator “Redirecting to payment…” when going to Stripe, so the user isn’t staring at nothing. After Stripe payment, when redirecting back, you might briefly show a “Activating your account…” message while your app creates the user and sets up their session, then transition to the homepage. These little cues and loading states improve the perceived smoothness of the flow.
Post-Cancel UX: If a user cancels their subscription, update the UI to reflect this. For example, after clicking cancel, instead of still showing a “Cancel Subscription” button, you could show text like “Subscription will end on [date]. (You can resume until that date).” and maybe change the button to “Resume Subscription” if you implement that. At minimum, ensure that if the user tries to click cancel again, you don’t keep calling the API repeatedly – either disable the button or change it. Also consider emailing the user a confirmation of cancellation with the end date, as a nice UX touch (though not strictly required, it’s common).
Overall, any point where the user might be confused, add messaging. If an error occurs at any step (failed API call, network error, etc.), present a descriptive error state in context. By handling errors and transitions gracefully, you prevent the user from getting stuck or feeling that the app is unresponsive. This addresses any previous issues where users may have seen nothing happen on clicking buttons or only saw brief toasts for critical information.
6. Responsive Design for All Screens
Make sure the entire flow is mobile-friendly and desktop-friendly. Review each screen and component (splash, onboarding slides, plan selection, Stripe redirect handling, popups, etc.) with responsiveness in mind:
Fluid Layouts: Use responsive units (percentages, flexbox, CSS grid) so that content adjusts to different screen widths. For example, the onboarding slides might be designed for desktop – ensure on a narrow screen they still look good (perhaps stack text and image vertically, use a smaller font, etc.). Use media queries to adjust styling if necessary (e.g. for screens < 600px wide, maybe increase padding or font size of buttons to be touch-friendly).
Splash/Login: The splash screen and login/register forms should center nicely on mobile and scale down. Use a column layout on mobile (one input per line) and maybe a side-by-side on larger screens if desired. Check that text isn’t overflowing off screen.
Onboarding Slides: If these have illustrations and text, ensure that on mobile the illustration shrinks to fit or moves above/below text. Avoid fixed heights that could cut off content on smaller devices. Swiping through slides on touch should work (or provide arrow buttons that are large enough on mobile). Test the slides on a phone-sized viewport.
Plan Selection Screen: This likely has the Free vs Premium options, and possibly pricing details. Make this into a responsive grid or stack. On desktop, you might show free and premium plans side by side; on mobile, you might stack them vertically for easier reading. Ensure buttons are full-width or easily tappable on a small screen. Also ensure that any toggle for monthly/yearly is usable on mobile (if it exists).
Stripe Checkout Page: The Stripe-hosted checkout is automatically responsive, so that part is handled by Stripe. Just ensure your redirect pages (success/cancel) are mobile-friendly as well.
Popups and Modals: The cancel confirmation dialog (and any other modal) must scale on small screens. Use CSS to have the modal take a good portion of the screen on mobile (perhaps near full-screen modal with a centered box), rather than a tiny fixed-size box. Use relative units so that if the screen is very small, the popup content can still be read without horizontal scrolling. Also ensure the overlay and positioning work on mobile (e.g. use position: fixed for the backdrop so it covers the whole screen). Test the cancel confirmation on a phone – the text and buttons should be legible and not cut off.
General: Check font sizes and touch targets. For mobile, buttons should have adequate height (at least ~44px) for comfortable tapping. Text may need to be slightly larger or wrap differently. Use the browser’s developer tools device simulator or actual devices to verify each step of the flow.
Responsive design fixes will resolve any prior issues where elements may have been misaligned or off-screen on certain devices. For example, if previously the onboarding or plan cards weren’t scaling, applying these adjustments will make the UI usable on all device sizes. The end goal is a seamless experience on mobile, tablet, and desktop for the entire signup and subscription management process.
7. Final Expected Outcome
After implementing the above fixes and enhancements, the subscription flow should work flawlessly for both free and premium users, meeting all the requirements:
Free Users: They can register and immediately use the app after onboarding. Upon finishing the onboarding slides and selecting the Free plan, their account is created and marked as free. They land on the homepage logged in. They have access to free-tier features without any payment prompts.
Premium Users (New Signups): New users who choose a premium plan are taken through Stripe Checkout in test mode. Only after they successfully pay, their account is created in the database. They are flagged as premium (e.g. user.plan = 'premium' or similar) and have a Stripe customer and subscription linked. They end up on the homepage logged in, with premium features enabled. If they abandon payment, no account exists (no accidental creation), and thus no access is granted.
Subscription Status Sync: The system stays in sync with Stripe. If a premium user’s payment succeeds or renews, the webhooks update their record (so they remain premium). If they cancel, the app knows it’s scheduled to end and eventually flips them to free at period end. This means no manual intervention is needed to manage who has access – it’s all automated via Stripe events. The user’s premium_until date (subscription end date) is correctly set and honored. On cancellation, the user retains premium access until that date, as expected.
Settings Page: Users can self-service upgrade or cancel. A free user clicking “Upgrade” will be sent to Stripe checkout for the subscription – on completion, their account gets upgraded to premium. A premium user clicking “Cancel” will see a confirmation, and upon confirming, their subscription is marked to end at period finish – they see feedback of their remaining time. The UI for these actions is clean and intuitive, with no non-functional dummy buttons.
Error Handling: Users are never left wondering what happened. If a payment fails, they see a clear error message and can try again. If any step goes wrong, the app guides them (e.g. “Unable to load payment page, please check your connection and try again”). This improves trust in the app’s payment process.
Smooth UX: The transitions from screen to screen (splash → onboarding → plan → homepage) are smooth and polished. There are no awkward pauses or unjustified redirects. New users always see the onboarding and plan selection (so the app is introduced properly). Returning users go straight to content (on subsequent logins, since they’ve already done onboarding). The visual indicators (loading spinners, animations) make the process feel professional and cohesive.
Responsive Interface: The entire flow is usable on any device. Mobile users can sign up, go through onboarding, and manage subscriptions without UI hiccups. Popups and layouts adjust to small screens. Desktop users see an optimized layout as well. This means the app can convert users no matter what device they use to sign up.
